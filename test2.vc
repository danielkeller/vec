[[int]] asdf;

if (x)
    asdf;
else
    dasfds;
 + fo + fpp;

sadf = [a, b, c];
type foo = {int}!6;

type bar = {foo}!3;

if (2 < 5)
    ferwf + food;


{bar} baf;
int beer;

int:int main = 
(
);

a + -b * c + d;
x @= 2 + 3 + h b, y, +=c << f;
a / (b:c++) / d{foof};
(
a && b;
`y : 8*9;
type asf = foo;
);

//TODO: don't expand types until sema phase.
//then, recursively expand along with everything else

//insert typedefs from function type params into function
//body's scope... somehow. they'd be useful though

//it might be nice to be able to output a compunit before
//sema so as to skip parsing of standard libs every time

//could do variadic templates:
//ie type foo?[A, B, ...] = [A first, B second, {[...]}];
//or whatever
//or have something that expands tuples into others like [a,b,?...]

//lambda syntax could be double parens (( a+b ))

//add storage duration specifier agg
//acts like static except initializer is run on first call to agg function
